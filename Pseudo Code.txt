roadList=list of road and junction objects
groupList=list of groups of road/junction and traffic light objects
endList=empty array
rateOfCars=the number of cars per in simulation second
time=the number of in simulation seconds per second
tempFraction=int(0)
carList=empty array
tracker=None

CLASS Car:
    METHOD constructor (self, currentRoad, route):
        self.route=route
        self.carLength=(RANDOMINT(0->8)*0.1)+1.2
        self.acceleration=0
        self.velocity=currentRoad.speedLimit-3+RANDOMINT(0->6)
        self.roadObject=currentRoad
        self.roadIndex=0
        self.distanceIntoRoadObject=0
        self.following=False
        self.follower=False

    METHOD tick (self, time):
        #average car length roughly = 4.6m
        IF self.following:
            self.acceleration = (self.following.velocity - self.velocity) * 5 * (1/(self.following.distanceIntoRoadObject - self.distanceIntoRoadObject+self.following.carLength))

        else:
            carList=self.roadObject.getCars()

            FOR car IN carList:
                IF car.distanceIntoRoadObject > self.distanceIntoRoadObject+car.carLength+1+(self.velocity*2):
                    car.follower=self
                    self.following=car
        
        IF self.route[self.index+1].typ = "TL":
            IF self.route[self.index+1].getLights(self.route) != "Green":
                IF self.roadObject.length-self.distanceIntoRoadObject>20:
                    self.acceleration = -1*(self.velocity-(self.roadObject.length-self.distanceIntoRoadObject)

        IF self.distanceIntoRoadObject >= self.roadObject.length:
            self.newRoad()


    METHOD newRoad (self):
        self.roadObject.carList.REMOVE(self)
        self.roadIndex+=1
        self.roadObject=route[roadIndex]
        self.roadObject.carList.APPEND(self)
        self.distanceIntoRoadObject=0
    
PROCEDURE wait (timePeriod):
    HALT program FOR timePeriod

FUNCTION findRoute (entry, exit):
    finalRoute=[]
    finalRoute.APPEND(entry)
    WHILE finalRoute[-1] != exit:
        tempConns=finalRoute[-1].getConnections()
        chosenConn=RANDOMINT(0->(LENGTH(tempConns)-1))
        chosenConn=tempConns[chosenConn]
        finalRoute.APPEND(chosenConn)
    RETURN finalRoute

FOR object IN roadList:
    IF LENGTH(object.connections) < 2:
        endList.APPEND(object)
        FOR direction IN object.geometry:
            IF direction==True and object.hasNoConnections(direction):
                object.end.APPEND(direction)

timePassed=time/60

WHILE TRUE:
    wait(1/60)
    
    newCars=(rateOfCars*time)+tempFraction
    tempFraction=newCars%1
    newCars=TRUNCATE(newCars)

    FOR (newCarNeeded=0; newCarNeeded<newCars; newCarNeeded+=1):
        FOR car IN carList:
        entryPoint=RANDOMINT(0->(LENGTH(endList)-1))

        IF car.roadObject != endList[entryPoint] or car.distanceIntoRoadObject != 0:
            exitPoint=RANDOMINT(0->(LENGTH(endList)-1))
            route=findRoute(endList[entryPoint], endList[exitPoint])

            newCar=Car(endList[entryPoint], route)
            endList[entryPoint].carList.APPEND(newCar.id)
            carList.APPEND(newCar)
        
    FOR car IN carList:
        car.tick(timePassed)

#math.modf(x)
#Return the fractional and integer parts of x. Both results carry the sign of x and are floats.
